---
title: "Mastering Salesforce Apex Triggers: Best Practices & Common Pitfalls"
date: 2025-03-17T04:20:26.265Z
author: Nick Huber
category: Developer
thumbnail: salesforce-jitterbit-integration-blog-img-1080x6282-2-.webp
---


# Mastering Salesforce Apex Triggers: Best Practices & Common Pitfalls

Salesforce Apex triggers are a powerful tool for automating complex business processes. However, poorly written triggers can lead to **governor limits, recursion issues, and performance bottlenecks**.

In this guide, we‚Äôll cover **the best practices for writing Apex triggers**, **common pitfalls to avoid**, and **real-world examples** to help you optimize your Salesforce development.

## üöÄ Why Optimize Apex Triggers?

A well-optimized trigger ensures:

- **Efficient bulk processing** (avoiding SOQL queries inside loops)
- **Preventing recursive execution** (avoiding infinite loops)
- **Reducing governor limit exceptions**
- **Enhancing maintainability** (separating logic into handler classes)

## üõ† Best Practices for Writing Apex Triggers

### 1Ô∏è‚É£ One Trigger Per Object

Having multiple triggers on the same object can result in **unpredictable execution order**. Instead, use a **single trigger per object** and delegate logic to a handler class.

‚úÖ **Example: Using a Trigger Handler**

```apex
trigger AccountTrigger on Account (before insert, before update, after insert, after update) {
    AccountTriggerHandler.handleTrigger(Trigger.new, Trigger.oldMap, Trigger.operationType);
}
```

This keeps the trigger lightweight and allows better scalability.

---

### 2Ô∏è‚É£ Bulkify Your Triggers

**Avoid SOQL queries inside loops** to prevent hitting governor limits.

‚ùå **Bad Example (Risky SOQL in Loop)**

```apex
for (Account acc : Trigger.new) {
    Contact c = [SELECT Id FROM Contact WHERE AccountId = :acc.Id LIMIT 1]; 
}
```

‚úÖ **Optimized Example (Bulkified Query)**

```apex
Map<Id, Account> accounts = new Map<Id, Account>([SELECT Id, Name FROM Account WHERE Id IN :Trigger.newMap.keySet()]);
```

This ensures that Salesforce only **executes one query instead of multiple queries**.

---

### 3Ô∏è‚É£ Prevent Recursive Execution

Triggers that update records can **accidentally re-trigger themselves**, causing **infinite loops**.

‚úÖ **Solution: Use Static Variables**

```apex
public class TriggerHelper {
    private static Boolean isTriggerRunning = false;
    
    public static Boolean shouldRun() {
        if (isTriggerRunning) return false;
        isTriggerRunning = true;
        return true;
    }
}
```

This ensures the trigger runs **only once per transaction**.

---

### 4Ô∏è‚É£ Use Context Variables

**Leverage `Trigger.old` and `Trigger.new`** to compare old and new values effectively.

‚úÖ **Example: Comparing Old and New Values in an Update Trigger**

```apex
for (Account acc : Trigger.new) {
    Account oldAcc = Trigger.oldMap.get(acc.Id);
    if (acc.Name != oldAcc.Name) {
        System.debug('Account name changed from ' + oldAcc.Name + ' to ' + acc.Name);
    }
}
```

This helps track changes efficiently without unnecessary queries.

---

### 5Ô∏è‚É£ Implement a Trigger Framework

Using an **Apex Trigger Framework** enhances code modularity and makes maintenance easier.

‚úÖ **Example: Base Trigger Framework**

```apex
public abstract class BaseTriggerHandler {
    public virtual void beforeInsert(List<SObject> newRecords) {}
    public virtual void beforeUpdate(List<SObject> newRecords, Map<Id, SObject> oldRecords) {}
}
```

This provides a **structured way to handle multiple trigger events** efficiently.

---

## ‚ö†Ô∏è Common Pitfalls to Avoid

‚ùå **Hardcoding Field Values:** Instead, use **Custom Metadata or Custom Settings**.

‚ùå **Trigger Logic Inside the Trigger:** Always delegate logic to a handler class.

‚ùå **DML Statements in Loops:** Batch updates to **prevent hitting governor limits**.

---

## üéØ Conclusion

By following these best practices, you can ensure that your Salesforce Apex triggers are **efficient, scalable, and maintainable**. Whether you're handling **data automation or enforcing business rules**, optimized triggers will **enhance your org‚Äôs performance**.

üöÄ **Want more Apex tips? Subscribe to our newsletter and stay ahead in Salesforce development!**

---

**üîó Recommended Reads:**

- [Comparing Old and New Values in an Apex Trigger](https://salesforcestack.com/comparing-old-and-new-values-in-an-apex-trigger/)
- [SOQL Queries Best Practices](https://salesforcestack.com/soql-best-practices/)
- [Handling Null Pointer Exceptions in Apex](https://salesforcestack.com/null-pointer-exceptions-in-apex/)
